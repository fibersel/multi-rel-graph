/*
 * generated by Xtext 2.27.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.SqlGrammarAccess;
import org.xtext.example.mydsl.sql.AddOrSubtractExpression;
import org.xtext.example.mydsl.sql.AndExpression;
import org.xtext.example.mydsl.sql.AttributeLookup;
import org.xtext.example.mydsl.sql.BooleanLiteral;
import org.xtext.example.mydsl.sql.Column;
import org.xtext.example.mydsl.sql.ComparisonExpression;
import org.xtext.example.mydsl.sql.ContainsExpression;
import org.xtext.example.mydsl.sql.Count;
import org.xtext.example.mydsl.sql.EndsWithExpression;
import org.xtext.example.mydsl.sql.Expression;
import org.xtext.example.mydsl.sql.FromItem;
import org.xtext.example.mydsl.sql.FunctionInvocation;
import org.xtext.example.mydsl.sql.GroupClause;
import org.xtext.example.mydsl.sql.HavingClause;
import org.xtext.example.mydsl.sql.InCollectionExpression;
import org.xtext.example.mydsl.sql.IsNotNullExpression;
import org.xtext.example.mydsl.sql.IsNullExpression;
import org.xtext.example.mydsl.sql.Model;
import org.xtext.example.mydsl.sql.MultiplyDivideModuloExpression;
import org.xtext.example.mydsl.sql.NotExpression;
import org.xtext.example.mydsl.sql.NumberLiteral;
import org.xtext.example.mydsl.sql.OrExpression;
import org.xtext.example.mydsl.sql.PowerOfExpression;
import org.xtext.example.mydsl.sql.Query;
import org.xtext.example.mydsl.sql.RegExpMatchingExpression;
import org.xtext.example.mydsl.sql.SelectSection;
import org.xtext.example.mydsl.sql.SqlPackage;
import org.xtext.example.mydsl.sql.StartsWithExpression;
import org.xtext.example.mydsl.sql.StringListNullOperatorExpression;
import org.xtext.example.mydsl.sql.StringLiteral;
import org.xtext.example.mydsl.sql.Table;
import org.xtext.example.mydsl.sql.UnaryAddOrSubtractExpression;
import org.xtext.example.mydsl.sql.VariableDeclaration;
import org.xtext.example.mydsl.sql.VariableRef;
import org.xtext.example.mydsl.sql.WhereClause;
import org.xtext.example.mydsl.sql.XorExpression;
import org.xtext.example.mydsl.sql.fromSection;

@SuppressWarnings("all")
public class SqlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SqlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SqlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SqlPackage.ADD_OR_SUBTRACT_EXPRESSION:
				sequence_AddOrSubtractExpression(context, (AddOrSubtractExpression) semanticObject); 
				return; 
			case SqlPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case SqlPackage.ATTRIBUTE_LOOKUP:
				sequence_AttributeLookup(context, (AttributeLookup) semanticObject); 
				return; 
			case SqlPackage.BOOLEAN_LITERAL:
				if (rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getBooleanLiteralRule()) {
					sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrRelationAttributeExpressionRule()) {
					sequence_BooleanLiteral_PropertyOrRelationAttributeExpression(context, (BooleanLiteral) semanticObject); 
					return; 
				}
				else break;
			case SqlPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case SqlPackage.COMPARISON_EXPRESSION:
				sequence_ComparisonExpression(context, (ComparisonExpression) semanticObject); 
				return; 
			case SqlPackage.CONTAINS_EXPRESSION:
				sequence_StringOperatorExpression(context, (ContainsExpression) semanticObject); 
				return; 
			case SqlPackage.COUNT:
				if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (Count) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrRelationAttributeExpressionRule()) {
					sequence_Atom_PropertyOrRelationAttributeExpression(context, (Count) semanticObject); 
					return; 
				}
				else break;
			case SqlPackage.ENDS_WITH_EXPRESSION:
				sequence_StringOperatorExpression(context, (EndsWithExpression) semanticObject); 
				return; 
			case SqlPackage.EXPRESSION:
				if (rule == grammarAccess.getBinaryRule()) {
					sequence_Binary(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBoolExpressionRule()) {
					sequence_BoolExpression(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFactorRule()) {
					sequence_Factor(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTermRule()) {
					sequence_Term(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case SqlPackage.FROM_ITEM:
				sequence_FromItem(context, (FromItem) semanticObject); 
				return; 
			case SqlPackage.FUNCTION_INVOCATION:
				if (rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getFunctionInvocationRule()) {
					sequence_FunctionInvocation(context, (FunctionInvocation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrRelationAttributeExpressionRule()) {
					sequence_FunctionInvocation_PropertyOrRelationAttributeExpression(context, (FunctionInvocation) semanticObject); 
					return; 
				}
				else break;
			case SqlPackage.GROUP_CLAUSE:
				sequence_GroupClause(context, (GroupClause) semanticObject); 
				return; 
			case SqlPackage.HAVING_CLAUSE:
				sequence_HavingClause(context, (HavingClause) semanticObject); 
				return; 
			case SqlPackage.IN_COLLECTION_EXPRESSION:
				sequence_StringOperatorExpression(context, (InCollectionExpression) semanticObject); 
				return; 
			case SqlPackage.IS_NOT_NULL_EXPRESSION:
				sequence_NullOperatorExpression(context, (IsNotNullExpression) semanticObject); 
				return; 
			case SqlPackage.IS_NULL_EXPRESSION:
				sequence_NullOperatorExpression(context, (IsNullExpression) semanticObject); 
				return; 
			case SqlPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SqlPackage.MULTIPLY_DIVIDE_MODULO_EXPRESSION:
				sequence_MultiplyDivideModuloExpression(context, (MultiplyDivideModuloExpression) semanticObject); 
				return; 
			case SqlPackage.NOT_EXPRESSION:
				sequence_NotExpression(context, (NotExpression) semanticObject); 
				return; 
			case SqlPackage.NUMBER_LITERAL:
				if (rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getNumberLiteralRule()) {
					sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrRelationAttributeExpressionRule()) {
					sequence_NumberLiteral_PropertyOrRelationAttributeExpression(context, (NumberLiteral) semanticObject); 
					return; 
				}
				else break;
			case SqlPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case SqlPackage.POWER_OF_EXPRESSION:
				sequence_PowerOfExpression(context, (PowerOfExpression) semanticObject); 
				return; 
			case SqlPackage.QUERY:
				sequence_Query(context, (Query) semanticObject); 
				return; 
			case SqlPackage.REG_EXP_MATCHING_EXPRESSION:
				sequence_StringOperatorExpression(context, (RegExpMatchingExpression) semanticObject); 
				return; 
			case SqlPackage.SELECT_SECTION:
				sequence_SelectSection(context, (SelectSection) semanticObject); 
				return; 
			case SqlPackage.STARTS_WITH_EXPRESSION:
				sequence_StringOperatorExpression(context, (StartsWithExpression) semanticObject); 
				return; 
			case SqlPackage.STRING_LIST_NULL_OPERATOR_EXPRESSION:
				sequence_StringListNullOperatorExpression(context, (StringListNullOperatorExpression) semanticObject); 
				return; 
			case SqlPackage.STRING_LITERAL:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrRelationAttributeExpressionRule()) {
					sequence_PropertyOrRelationAttributeExpression_StringLiteral(context, (StringLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getStringLiteralRule()) {
					sequence_StringLiteral(context, (StringLiteral) semanticObject); 
					return; 
				}
				else break;
			case SqlPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case SqlPackage.UNARY_ADD_OR_SUBTRACT_EXPRESSION:
				sequence_UnaryAddOrSubtractExpression(context, (UnaryAddOrSubtractExpression) semanticObject); 
				return; 
			case SqlPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case SqlPackage.VARIABLE_REF:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0()
						|| rule == grammarAccess.getNotExpressionRule()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddOrSubtractExpressionRule()
						|| action == grammarAccess.getAddOrSubtractExpressionAccess().getAddOrSubtractExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplyDivideModuloExpressionRule()
						|| action == grammarAccess.getMultiplyDivideModuloExpressionAccess().getMultiplyDivideModuloExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerOfExpressionRule()
						|| action == grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryAddOrSubtractExpressionRule()
						|| rule == grammarAccess.getStringListNullOperatorExpressionRule()
						|| action == grammarAccess.getStringListNullOperatorExpressionAccess().getStringListNullOperatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPropertyOrRelationAttributeExpressionRule()) {
					sequence_Atom_PropertyOrRelationAttributeExpression(context, (VariableRef) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (VariableRef) semanticObject); 
					return; 
				}
				else break;
			case SqlPackage.WHERE_CLAUSE:
				sequence_WhereClause(context, (WhereClause) semanticObject); 
				return; 
			case SqlPackage.XOR_EXPRESSION:
				sequence_XorExpression(context, (XorExpression) semanticObject); 
				return; 
			case SqlPackage.FROM_SECTION:
				sequence_fromSection(context, (fromSection) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AddOrSubtractExpression
	 *     OrExpression returns AddOrSubtractExpression
	 *     OrExpression.OrExpression_1_0 returns AddOrSubtractExpression
	 *     XorExpression returns AddOrSubtractExpression
	 *     XorExpression.XorExpression_1_0 returns AddOrSubtractExpression
	 *     AndExpression returns AddOrSubtractExpression
	 *     AndExpression.AndExpression_1_0 returns AddOrSubtractExpression
	 *     NotExpression returns AddOrSubtractExpression
	 *     ComparisonExpression returns AddOrSubtractExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns AddOrSubtractExpression
	 *     AddOrSubtractExpression returns AddOrSubtractExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns AddOrSubtractExpression
	 *
	 * Constraint:
	 *     (left=AddOrSubtractExpression_AddOrSubtractExpression_1_0 (operator='+' | operator='-') right=MultiplyDivideModuloExpression)
	 * </pre>
	 */
	protected void sequence_AddOrSubtractExpression(ISerializationContext context, AddOrSubtractExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0 returns AndExpression
	 *     XorExpression returns AndExpression
	 *     XorExpression.XorExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 operator='AND' right=NotExpression)
	 * </pre>
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.AND_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.AND_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getOperatorANDKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightNotExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Atom returns Count
	 *
	 * Constraint:
	 *     {Count}
	 * </pre>
	 */
	protected void sequence_Atom(ISerializationContext context, Count semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Count
	 *     OrExpression returns Count
	 *     OrExpression.OrExpression_1_0 returns Count
	 *     XorExpression returns Count
	 *     XorExpression.XorExpression_1_0 returns Count
	 *     AndExpression returns Count
	 *     AndExpression.AndExpression_1_0 returns Count
	 *     NotExpression returns Count
	 *     ComparisonExpression returns Count
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Count
	 *     AddOrSubtractExpression returns Count
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns Count
	 *     MultiplyDivideModuloExpression returns Count
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns Count
	 *     PowerOfExpression returns Count
	 *     PowerOfExpression.PowerOfExpression_1_0 returns Count
	 *     UnaryAddOrSubtractExpression returns Count
	 *     StringListNullOperatorExpression returns Count
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns Count
	 *     PropertyOrRelationAttributeExpression returns Count
	 *
	 * Constraint:
	 *     attributeLookup=AttributeLookup?
	 * </pre>
	 */
	protected void sequence_Atom_PropertyOrRelationAttributeExpression(ISerializationContext context, Count semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns VariableRef
	 *     OrExpression returns VariableRef
	 *     OrExpression.OrExpression_1_0 returns VariableRef
	 *     XorExpression returns VariableRef
	 *     XorExpression.XorExpression_1_0 returns VariableRef
	 *     AndExpression returns VariableRef
	 *     AndExpression.AndExpression_1_0 returns VariableRef
	 *     NotExpression returns VariableRef
	 *     ComparisonExpression returns VariableRef
	 *     ComparisonExpression.ComparisonExpression_1_0 returns VariableRef
	 *     AddOrSubtractExpression returns VariableRef
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns VariableRef
	 *     MultiplyDivideModuloExpression returns VariableRef
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns VariableRef
	 *     PowerOfExpression returns VariableRef
	 *     PowerOfExpression.PowerOfExpression_1_0 returns VariableRef
	 *     UnaryAddOrSubtractExpression returns VariableRef
	 *     StringListNullOperatorExpression returns VariableRef
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns VariableRef
	 *     PropertyOrRelationAttributeExpression returns VariableRef
	 *
	 * Constraint:
	 *     (variableRef=VariableDeclaration attributeLookup=AttributeLookup?)
	 * </pre>
	 */
	protected void sequence_Atom_PropertyOrRelationAttributeExpression(ISerializationContext context, VariableRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Atom returns VariableRef
	 *
	 * Constraint:
	 *     variableRef=VariableDeclaration
	 * </pre>
	 */
	protected void sequence_Atom(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.VARIABLE_REF__VARIABLE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.VARIABLE_REF__VARIABLE_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getVariableRefVariableDeclarationParserRuleCall_2_1_0(), semanticObject.getVariableRef());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeLookup returns AttributeLookup
	 *
	 * Constraint:
	 *     attributeKeyName=AttributeKeyName
	 * </pre>
	 */
	protected void sequence_AttributeLookup(ISerializationContext context, AttributeLookup semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.ATTRIBUTE_LOOKUP__ATTRIBUTE_KEY_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.ATTRIBUTE_LOOKUP__ATTRIBUTE_KEY_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeLookupAccess().getAttributeKeyNameAttributeKeyNameParserRuleCall_1_0(), semanticObject.getAttributeKeyName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Binary returns Expression
	 *
	 * Constraint:
	 *     (lhs=PropertyOrRelationAttributeExpression rhs=PropertyOrRelationAttributeExpression)
	 * </pre>
	 */
	protected void sequence_Binary(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryAccess().getLhsPropertyOrRelationAttributeExpressionParserRuleCall_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getBinaryAccess().getRhsPropertyOrRelationAttributeExpressionParserRuleCall_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BoolExpression returns Expression
	 *
	 * Constraint:
	 *     (lhs=Term rhs=Term?)
	 * </pre>
	 */
	protected void sequence_BoolExpression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Atom returns BooleanLiteral
	 *     Literal returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value='TRUE' | value='FALSE')
	 * </pre>
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BooleanLiteral
	 *     OrExpression returns BooleanLiteral
	 *     OrExpression.OrExpression_1_0 returns BooleanLiteral
	 *     XorExpression returns BooleanLiteral
	 *     XorExpression.XorExpression_1_0 returns BooleanLiteral
	 *     AndExpression returns BooleanLiteral
	 *     AndExpression.AndExpression_1_0 returns BooleanLiteral
	 *     NotExpression returns BooleanLiteral
	 *     ComparisonExpression returns BooleanLiteral
	 *     ComparisonExpression.ComparisonExpression_1_0 returns BooleanLiteral
	 *     AddOrSubtractExpression returns BooleanLiteral
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns BooleanLiteral
	 *     MultiplyDivideModuloExpression returns BooleanLiteral
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns BooleanLiteral
	 *     PowerOfExpression returns BooleanLiteral
	 *     PowerOfExpression.PowerOfExpression_1_0 returns BooleanLiteral
	 *     UnaryAddOrSubtractExpression returns BooleanLiteral
	 *     StringListNullOperatorExpression returns BooleanLiteral
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns BooleanLiteral
	 *     PropertyOrRelationAttributeExpression returns BooleanLiteral
	 *
	 * Constraint:
	 *     ((value='TRUE' | value='FALSE') attributeLookup=AttributeLookup?)
	 * </pre>
	 */
	protected void sequence_BooleanLiteral_PropertyOrRelationAttributeExpression(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Column returns Column
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.COLUMN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.COLUMN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ComparisonExpression
	 *     OrExpression returns ComparisonExpression
	 *     OrExpression.OrExpression_1_0 returns ComparisonExpression
	 *     XorExpression returns ComparisonExpression
	 *     XorExpression.XorExpression_1_0 returns ComparisonExpression
	 *     AndExpression returns ComparisonExpression
	 *     AndExpression.AndExpression_1_0 returns ComparisonExpression
	 *     NotExpression returns ComparisonExpression
	 *     ComparisonExpression returns ComparisonExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ComparisonExpression
	 *
	 * Constraint:
	 *     (
	 *         left=ComparisonExpression_ComparisonExpression_1_0 
	 *         (
	 *             operator='=' | 
	 *             operator='&lt;&gt;' | 
	 *             operator='&lt;' | 
	 *             operator='&gt;' | 
	 *             operator='&lt;=' | 
	 *             operator='&gt;='
	 *         ) 
	 *         right=AddOrSubtractExpression
	 *     )
	 * </pre>
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, ComparisonExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Factor returns Expression
	 *
	 * Constraint:
	 *     (factor=Factor | expr=BoolExpression | binexp=Binary)
	 * </pre>
	 */
	protected void sequence_Factor(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FromItem returns FromItem
	 *
	 * Constraint:
	 *     ((tbl+=Table (tbl+=Table expressions+=Expression)*) | select_expr=SelectSection)
	 * </pre>
	 */
	protected void sequence_FromItem(ISerializationContext context, FromItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Atom returns FunctionInvocation
	 *     FunctionInvocation returns FunctionInvocation
	 *
	 * Constraint:
	 *     (functionName=FunctionName (parameter+=Expression parameter+=Expression*)?)
	 * </pre>
	 */
	protected void sequence_FunctionInvocation(ISerializationContext context, FunctionInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns FunctionInvocation
	 *     OrExpression returns FunctionInvocation
	 *     OrExpression.OrExpression_1_0 returns FunctionInvocation
	 *     XorExpression returns FunctionInvocation
	 *     XorExpression.XorExpression_1_0 returns FunctionInvocation
	 *     AndExpression returns FunctionInvocation
	 *     AndExpression.AndExpression_1_0 returns FunctionInvocation
	 *     NotExpression returns FunctionInvocation
	 *     ComparisonExpression returns FunctionInvocation
	 *     ComparisonExpression.ComparisonExpression_1_0 returns FunctionInvocation
	 *     AddOrSubtractExpression returns FunctionInvocation
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns FunctionInvocation
	 *     MultiplyDivideModuloExpression returns FunctionInvocation
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns FunctionInvocation
	 *     PowerOfExpression returns FunctionInvocation
	 *     PowerOfExpression.PowerOfExpression_1_0 returns FunctionInvocation
	 *     UnaryAddOrSubtractExpression returns FunctionInvocation
	 *     StringListNullOperatorExpression returns FunctionInvocation
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns FunctionInvocation
	 *     PropertyOrRelationAttributeExpression returns FunctionInvocation
	 *
	 * Constraint:
	 *     (functionName=FunctionName (parameter+=Expression parameter+=Expression*)? attributeLookup=AttributeLookup?)
	 * </pre>
	 */
	protected void sequence_FunctionInvocation_PropertyOrRelationAttributeExpression(ISerializationContext context, FunctionInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GroupClause returns GroupClause
	 *
	 * Constraint:
	 *     (expressions+=Expression expressions+=Expression*)
	 * </pre>
	 */
	protected void sequence_GroupClause(ISerializationContext context, GroupClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     HavingClause returns HavingClause
	 *
	 * Constraint:
	 *     expr=BoolExpression
	 * </pre>
	 */
	protected void sequence_HavingClause(ISerializationContext context, HavingClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.HAVING_CLAUSE__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.HAVING_CLAUSE__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHavingClauseAccess().getExprBoolExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     queries+=Query+
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns MultiplyDivideModuloExpression
	 *     OrExpression returns MultiplyDivideModuloExpression
	 *     OrExpression.OrExpression_1_0 returns MultiplyDivideModuloExpression
	 *     XorExpression returns MultiplyDivideModuloExpression
	 *     XorExpression.XorExpression_1_0 returns MultiplyDivideModuloExpression
	 *     AndExpression returns MultiplyDivideModuloExpression
	 *     AndExpression.AndExpression_1_0 returns MultiplyDivideModuloExpression
	 *     NotExpression returns MultiplyDivideModuloExpression
	 *     ComparisonExpression returns MultiplyDivideModuloExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns MultiplyDivideModuloExpression
	 *     AddOrSubtractExpression returns MultiplyDivideModuloExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns MultiplyDivideModuloExpression
	 *     MultiplyDivideModuloExpression returns MultiplyDivideModuloExpression
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns MultiplyDivideModuloExpression
	 *
	 * Constraint:
	 *     (left=MultiplyDivideModuloExpression_MultiplyDivideModuloExpression_1_0 (operator='*' | operator='/' | operator='%') right=PowerOfExpression)
	 * </pre>
	 */
	protected void sequence_MultiplyDivideModuloExpression(ISerializationContext context, MultiplyDivideModuloExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NotExpression
	 *     OrExpression returns NotExpression
	 *     OrExpression.OrExpression_1_0 returns NotExpression
	 *     XorExpression returns NotExpression
	 *     XorExpression.XorExpression_1_0 returns NotExpression
	 *     AndExpression returns NotExpression
	 *     AndExpression.AndExpression_1_0 returns NotExpression
	 *     NotExpression returns NotExpression
	 *
	 * Constraint:
	 *     (operator='NOT' left=NotExpression)
	 * </pre>
	 */
	protected void sequence_NotExpression(ISerializationContext context, NotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.NOT_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.NOT_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.NOT_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.NOT_EXPRESSION__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotExpressionAccess().getOperatorNOTKeyword_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getNotExpressionAccess().getLeftNotExpressionParserRuleCall_0_2_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NullOperatorExpression returns IsNotNullExpression
	 *
	 * Constraint:
	 *     {IsNotNullExpression}
	 * </pre>
	 */
	protected void sequence_NullOperatorExpression(ISerializationContext context, IsNotNullExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NullOperatorExpression returns IsNullExpression
	 *
	 * Constraint:
	 *     {IsNullExpression}
	 * </pre>
	 */
	protected void sequence_NullOperatorExpression(ISerializationContext context, IsNullExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Atom returns NumberLiteral
	 *     Literal returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     value=Number
	 * </pre>
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralAccess().getValueNumberParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NumberLiteral
	 *     OrExpression returns NumberLiteral
	 *     OrExpression.OrExpression_1_0 returns NumberLiteral
	 *     XorExpression returns NumberLiteral
	 *     XorExpression.XorExpression_1_0 returns NumberLiteral
	 *     AndExpression returns NumberLiteral
	 *     AndExpression.AndExpression_1_0 returns NumberLiteral
	 *     NotExpression returns NumberLiteral
	 *     ComparisonExpression returns NumberLiteral
	 *     ComparisonExpression.ComparisonExpression_1_0 returns NumberLiteral
	 *     AddOrSubtractExpression returns NumberLiteral
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns NumberLiteral
	 *     MultiplyDivideModuloExpression returns NumberLiteral
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns NumberLiteral
	 *     PowerOfExpression returns NumberLiteral
	 *     PowerOfExpression.PowerOfExpression_1_0 returns NumberLiteral
	 *     UnaryAddOrSubtractExpression returns NumberLiteral
	 *     StringListNullOperatorExpression returns NumberLiteral
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns NumberLiteral
	 *     PropertyOrRelationAttributeExpression returns NumberLiteral
	 *
	 * Constraint:
	 *     (value=Number attributeLookup=AttributeLookup?)
	 * </pre>
	 */
	protected void sequence_NumberLiteral_PropertyOrRelationAttributeExpression(ISerializationContext context, NumberLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0 returns OrExpression
	 *
	 * Constraint:
	 *     (left=OrExpression_OrExpression_1_0 operator='OR' right=XorExpression)
	 * </pre>
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.OR_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.OR_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExpressionAccess().getOperatorORKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightXorExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns PowerOfExpression
	 *     OrExpression returns PowerOfExpression
	 *     OrExpression.OrExpression_1_0 returns PowerOfExpression
	 *     XorExpression returns PowerOfExpression
	 *     XorExpression.XorExpression_1_0 returns PowerOfExpression
	 *     AndExpression returns PowerOfExpression
	 *     AndExpression.AndExpression_1_0 returns PowerOfExpression
	 *     NotExpression returns PowerOfExpression
	 *     ComparisonExpression returns PowerOfExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns PowerOfExpression
	 *     AddOrSubtractExpression returns PowerOfExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns PowerOfExpression
	 *     MultiplyDivideModuloExpression returns PowerOfExpression
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns PowerOfExpression
	 *     PowerOfExpression returns PowerOfExpression
	 *     PowerOfExpression.PowerOfExpression_1_0 returns PowerOfExpression
	 *
	 * Constraint:
	 *     (left=PowerOfExpression_PowerOfExpression_1_0 operator='^' right=UnaryAddOrSubtractExpression)
	 * </pre>
	 */
	protected void sequence_PowerOfExpression(ISerializationContext context, PowerOfExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.POWER_OF_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.POWER_OF_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.POWER_OF_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.POWER_OF_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.POWER_OF_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.POWER_OF_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerOfExpressionAccess().getPowerOfExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPowerOfExpressionAccess().getOperatorCircumflexAccentKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getPowerOfExpressionAccess().getRightUnaryAddOrSubtractExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     OrExpression returns StringLiteral
	 *     OrExpression.OrExpression_1_0 returns StringLiteral
	 *     XorExpression returns StringLiteral
	 *     XorExpression.XorExpression_1_0 returns StringLiteral
	 *     AndExpression returns StringLiteral
	 *     AndExpression.AndExpression_1_0 returns StringLiteral
	 *     NotExpression returns StringLiteral
	 *     ComparisonExpression returns StringLiteral
	 *     ComparisonExpression.ComparisonExpression_1_0 returns StringLiteral
	 *     AddOrSubtractExpression returns StringLiteral
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns StringLiteral
	 *     MultiplyDivideModuloExpression returns StringLiteral
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns StringLiteral
	 *     PowerOfExpression returns StringLiteral
	 *     PowerOfExpression.PowerOfExpression_1_0 returns StringLiteral
	 *     UnaryAddOrSubtractExpression returns StringLiteral
	 *     StringListNullOperatorExpression returns StringLiteral
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns StringLiteral
	 *     PropertyOrRelationAttributeExpression returns StringLiteral
	 *
	 * Constraint:
	 *     (value=STRING_LITERAL attributeLookup=AttributeLookup?)
	 * </pre>
	 */
	protected void sequence_PropertyOrRelationAttributeExpression_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Query returns Query
	 *
	 * Constraint:
	 *     (selectClause=SelectSection fromClause=fromSection? whereClause=WhereClause? groupClause=GroupClause? havingClause=HavingClause?)
	 * </pre>
	 */
	protected void sequence_Query(ISerializationContext context, Query semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SelectSection returns SelectSection
	 *
	 * Constraint:
	 *     (expressions+=Expression expressions+=Expression*)
	 * </pre>
	 */
	protected void sequence_SelectSection(ISerializationContext context, SelectSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns StringListNullOperatorExpression
	 *     OrExpression returns StringListNullOperatorExpression
	 *     OrExpression.OrExpression_1_0 returns StringListNullOperatorExpression
	 *     XorExpression returns StringListNullOperatorExpression
	 *     XorExpression.XorExpression_1_0 returns StringListNullOperatorExpression
	 *     AndExpression returns StringListNullOperatorExpression
	 *     AndExpression.AndExpression_1_0 returns StringListNullOperatorExpression
	 *     NotExpression returns StringListNullOperatorExpression
	 *     ComparisonExpression returns StringListNullOperatorExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns StringListNullOperatorExpression
	 *     AddOrSubtractExpression returns StringListNullOperatorExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns StringListNullOperatorExpression
	 *     MultiplyDivideModuloExpression returns StringListNullOperatorExpression
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns StringListNullOperatorExpression
	 *     PowerOfExpression returns StringListNullOperatorExpression
	 *     PowerOfExpression.PowerOfExpression_1_0 returns StringListNullOperatorExpression
	 *     UnaryAddOrSubtractExpression returns StringListNullOperatorExpression
	 *     StringListNullOperatorExpression returns StringListNullOperatorExpression
	 *     StringListNullOperatorExpression.StringListNullOperatorExpression_1_0 returns StringListNullOperatorExpression
	 *
	 * Constraint:
	 *     (
	 *         left=StringListNullOperatorExpression_StringListNullOperatorExpression_1_0 
	 *         (expressions+=StringOperatorExpression | expressions+=NullOperatorExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_StringListNullOperatorExpression(ISerializationContext context, StringListNullOperatorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Atom returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING_LITERAL
	 * </pre>
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRING_LITERALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringOperatorExpression returns ContainsExpression
	 *
	 * Constraint:
	 *     right=PropertyOrRelationAttributeExpression
	 * </pre>
	 */
	protected void sequence_StringOperatorExpression(ISerializationContext context, ContainsExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringOperatorExpressionAccess().getRightPropertyOrRelationAttributeExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringOperatorExpression returns EndsWithExpression
	 *
	 * Constraint:
	 *     right=PropertyOrRelationAttributeExpression
	 * </pre>
	 */
	protected void sequence_StringOperatorExpression(ISerializationContext context, EndsWithExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringOperatorExpressionAccess().getRightPropertyOrRelationAttributeExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringOperatorExpression returns InCollectionExpression
	 *
	 * Constraint:
	 *     right=PropertyOrRelationAttributeExpression
	 * </pre>
	 */
	protected void sequence_StringOperatorExpression(ISerializationContext context, InCollectionExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringOperatorExpressionAccess().getRightPropertyOrRelationAttributeExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringOperatorExpression returns RegExpMatchingExpression
	 *
	 * Constraint:
	 *     right=PropertyOrRelationAttributeExpression
	 * </pre>
	 */
	protected void sequence_StringOperatorExpression(ISerializationContext context, RegExpMatchingExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringOperatorExpressionAccess().getRightPropertyOrRelationAttributeExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringOperatorExpression returns StartsWithExpression
	 *
	 * Constraint:
	 *     right=PropertyOrRelationAttributeExpression
	 * </pre>
	 */
	protected void sequence_StringOperatorExpression(ISerializationContext context, StartsWithExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringOperatorExpressionAccess().getRightPropertyOrRelationAttributeExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Table returns Table
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.TABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.TABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Term returns Expression
	 *
	 * Constraint:
	 *     (lhs=Factor rhs=Factor?)
	 * </pre>
	 */
	protected void sequence_Term(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns UnaryAddOrSubtractExpression
	 *     OrExpression returns UnaryAddOrSubtractExpression
	 *     OrExpression.OrExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     XorExpression returns UnaryAddOrSubtractExpression
	 *     XorExpression.XorExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     AndExpression returns UnaryAddOrSubtractExpression
	 *     AndExpression.AndExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     NotExpression returns UnaryAddOrSubtractExpression
	 *     ComparisonExpression returns UnaryAddOrSubtractExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     AddOrSubtractExpression returns UnaryAddOrSubtractExpression
	 *     AddOrSubtractExpression.AddOrSubtractExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     MultiplyDivideModuloExpression returns UnaryAddOrSubtractExpression
	 *     MultiplyDivideModuloExpression.MultiplyDivideModuloExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     PowerOfExpression returns UnaryAddOrSubtractExpression
	 *     PowerOfExpression.PowerOfExpression_1_0 returns UnaryAddOrSubtractExpression
	 *     UnaryAddOrSubtractExpression returns UnaryAddOrSubtractExpression
	 *
	 * Constraint:
	 *     ((operator='+' | operator='-') left=UnaryAddOrSubtractExpression)
	 * </pre>
	 */
	protected void sequence_UnaryAddOrSubtractExpression(ISerializationContext context, UnaryAddOrSubtractExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     name=SYMBOLIC_NAME_X
	 * </pre>
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.VARIABLE_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameSYMBOLIC_NAME_XParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WhereClause returns WhereClause
	 *
	 * Constraint:
	 *     expression=Expression
	 * </pre>
	 */
	protected void sequence_WhereClause(ISerializationContext context, WhereClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.WHERE_CLAUSE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.WHERE_CLAUSE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhereClauseAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns XorExpression
	 *     OrExpression returns XorExpression
	 *     OrExpression.OrExpression_1_0 returns XorExpression
	 *     XorExpression returns XorExpression
	 *     XorExpression.XorExpression_1_0 returns XorExpression
	 *
	 * Constraint:
	 *     (left=XorExpression_XorExpression_1_0 operator='XOR' right=AndExpression)
	 * </pre>
	 */
	protected void sequence_XorExpression(ISerializationContext context, XorExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.XOR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.XOR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.XOR_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.XOR_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.XOR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.XOR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXorExpressionAccess().getOperatorXORKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getXorExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     fromSection returns fromSection
	 *
	 * Constraint:
	 *     fromItem=FromItem
	 * </pre>
	 */
	protected void sequence_fromSection(ISerializationContext context, fromSection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SqlPackage.Literals.FROM_SECTION__FROM_ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SqlPackage.Literals.FROM_SECTION__FROM_ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFromSectionAccess().getFromItemFromItemParserRuleCall_1_0(), semanticObject.getFromItem());
		feeder.finish();
	}
	
	
}
